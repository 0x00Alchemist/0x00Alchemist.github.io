{
    "version": "https://jsonfeed.org/version/1",
    "title": "alchemist.",
    "home_page_url": "http://localhost:4000/",
    "feed_url": "http://localhost:4000/feed.json",
    "description": "blog about windows and UEFI",
    "icon": "http://localhost:4000/apple-touch-icon.png",
    "favicon": "http://localhost:4000/favicon.ico",
    "expired": false,
    
    "author":  {
        "name": "alchemist",
        "url": null,
        "avatar": null
    },
    
"items": [
    
        {
            "id": "http://localhost:4000/2022/11/18/driver-signature-enforcement-%D0%B8%D0%BB%D0%B8-%D0%B8%D1%81%D1%81%D0%BB%D0%B5%D0%B4%D1%83%D0%B5%D0%BC-dse",
            "title": "Drowning In The Kernel - Driver Signature Enforcement!",
            "summary": "Исследуем инициализацию механизма проверки подписи драйверов в Windows",
            "content_text": "Хм.Допустим, мы должны убедиться, что у какого-либо драйвера есть собственная цифровая подпись. Так и еще чтоб она была валидной! Логично, что для этого нужен какой-либо механизм, совершающий подобные проверки. Ну, что же, да, таков есть в Windows и ни для кого это не секрет.Садитесь удобнее, сегодня мы попытаемся понять, где обитает DSE и почему он причиняет боль многим любителям говна в режиме ядра.Что такое DSE?DSE - аббревиатура от словосочетания Driver Signature Enforcement. На самом деле это весьма комплексный механизм Code Integrity, он существует для “защиты” от неподписанных компонентов ядра, следовательно предполагает, что каждый драйвер устройства (или иной другой системный файл, выгружаемый в адресное пространство ядра) должен иметь собственную цифровую подпись. В противном случае, система просто откажется грузить этот компонент.Стоит на всякий случай сказать, что изменение системных файлов убивает подпись, поэтому, мои маленькие любители подрочить в ядре, это не прокатит и система скажет, что такой файл не загрузит! Так что да, эта технология существует по большому счету для защиты от вредоносов, работающих на уровне ядра. И, в принципе, он справляется вполне себе неплохо!DSE включен по стандарту, но пользователям (только из под админа, конечно же) предоставляется возможность выключить на время проверку подписей (или включить Test Signing Mode, позволяющий загружать самоподписанные драйвера), например, через bcdedit. Правда, это чаще всего нужно только для разработчиков драйверов, когда они тестируют свои наработки.С понятием DSE мы вроде разобрались, перейдем к теперь к его инициализации.Инициализация Driver Signature Enforcement и Code IntegrityDSE является компонентом ядра, а значит, надо искать примерно на этом уровне или чуточку ниже.DSE берет свое начало с фазы “ранней загрузки” системы - когда свое дело закончили загрузчики (в данном случае - winload.exe/winload.efi). Это дело выгружается с основными драйверами системы. Нужный нам покемон находится в CI.dll (CodeIntegrity). Если обратить внимание на то, что экспортирует данная DLL мы однозначно можем сказать, что нам нужна функция под именем CiInitialize:Однако, давайте не спешить, мы зайдем немного с другого угла и чуточку уйдем от CI.dll.Все же не менее важным для ОС, как ни странно, является ядро, а это значит, что упоминание CiInitialize должно быть и там.В действительности, так и есть, более того, эта функция также вызывается во время инициализации системы. Барабанная дробь…Давайте посмотрим на функцию из ntoskrnl.exe - SepInitializeCodeIntegrity.А теперь приведем её в более приличный (и правильный) вид. Заодно я оставлю её как “код”, надеюсь, так будет удобнее:NTSTATUS SepInitializeCodeIntegrity() {   unsigned int CiOptions;   _LIST_ENTRY *p_BootDriverListHead;   _LOADER_PARAMETER_EXTENSION *Ext;   _LOADER_PARAMETER_CI_EXTENSION *CodeIntegrityData;   char *LoadOptions;   CiOptions = 6;   memset(&amp;CodeIntegrityCallbacks, 0, 0xC4); // nt!SeCiCallbacks   p_BootDriverListHead = 0;   SeCiCallbacks = 0xD0;   qword_140C1DAA8 = 0xA000008; // nt!SeCiCallbacks + 0xC8   if(KeLoaderBlock ) {      Ext = KeLoaderBlock-&gt;Extension;       if(Ext) {           CodeIntegrityData = Ext-&gt;CodeIntegrityData;           if(CodeIntegrityData)               CiOptions = CodeIntegrityData-&gt;CodeIntegrityOptions;       }       // (KeLoaderBlock + 0xD8)       LoadOptions = KeLoaderBlock-&gt;LoadOptions;       if(SepIsOptionPresent(LoadOptions) &amp;&amp; LoadOptions)           SeCiDebugOptions |= 1;       if(KeLoaderBlock)           p_BootDriverListHead = &amp;KeLoaderBlock-&gt;BootDriverListHead;   }   return CiInitialize(CiOptions, p_BootDriverListHead, &amp;SeCiCallbacks, SeCiPrivateApis);}Именно в этой функции мы получаем информацию о существовании CiInitialize впервые, правда, уже через само ядро. Думаю, стоит разобрать поближе несколько моментов.И начну я пожалуй с SeCiPrivateApis, так как они требуют меньше объяснений и о них можно сказать прямо сейчас. Из названия логично предположить, что SeCiPrivateApis содержит в себе список некоторых функций, с которыми работает модуль Code Integrity. Данный список содержит в себе оффсеты на функции: PsQueryProcessSignatureMitigationPolicy, VslHvciInterface (это оффсет на VslCreateSecureAllocation), SepZwLockRegistryKey, PsQuerySectionSignatureInformation, SepSetRuntimeUpdatableSigningLevel, RtlValidProcessProtection, MmGetImageFileSignatureInformation и SepGetSystemSigningLevel.Данные функции не будут разбираться в этой статье, однако, я покажу несколько из них.Назначение SeCiCallbacks я разберу в следующем параграфе. Также, не выкидывайте из головы структуру _LOADER_PARAMETER_CI_EXTENSIONS, с ней есть одна забавная особенность.Кстати, забыл показать call stack. Да, функция и в правду вызывается во время инициализации:От ядра к модулюХорошо, мы поняли, что за инициализацию DSE в ядре отвечает функция SepInitializeCodeIntegrity, данная функция срабатывает во время инициализации самой системы и она вызывает нужный нам CiInitialize. Самое время глянуть на CiInitialize! Ииииииии…Да, это очередной враппер над еще одной функцией - CipInitialize. Интересно, что тут мы имеем упоминание Microsoft WIL (Windows Implementation Library). Это нас не должно особо волновать, данные вещи нам не нужны и не мешают, но, решил просто это отметить.Хорошо, CiInitialize - это враппер. Значит, идем прямиком в CipInitialize! И, да, это она, именно она отвечает за инициализацию нашего DSE. Это весьма большая функция, поэтому придется разместить её на нескольких скринах. Надеюсь, вы не против.Отлично, мы нашли, где инициализируется DSE! Давайте разберем наиболее примечательные детали.Данный отрывок проверяет, существует ли оффсет на VslHvciInterface. Если да - заполняет таблицу g_CiVslHvciInterface. Я так и не смог понять, точно ли это то, что должно быть в данной таблице (да-да, называйте меня дауном-долбоебом-уебком-etc), поэтому, не упомяну ничего здесь во избежание ошибок. Но, предполагаю, что загружает оно какую-то часть функций отсюда:Скорее всего оно загружает все, начиная с VslCreateSecureAllocation (присутствует в CiPrivateApis) + 0x10.Здесь при вызове HashpSelfTest CI.dll тестирует собственную подпись, что очевидно. В условии тестируются собственные “Root Table”.А вот здесь у нас есть немножечко примеси Xbox (XciInitialize импортируется из ext-ms-win-ci-xbox-l1-1-0), живите с этим.А вот и самое главное - таблица коллбеков! Именно функции этой таблицы и отвечают за проверку подписей, а значит, мы технически нашли, то, что нам нужно!Самое главное, что делает CipInitialize - заполняет таблицу CiCallbacks, а CiInitialize передает заполненную таблицу ядру. Теперь, мы поняли, как иницализируется механизм проверки подписей. Осталось понять, каким образом проверяются загружаемые системные модули.Мы любим только проверенные образыКогда необходимая таблица с указателями на функции заполнилась - система может начинать совершать проверку загружаемых образов в пространство ядра.Опытным путем было найдено несколько функций, отвечающих за это. Например, SeValidateImageHeader:Здесь проводится проверка, существует ли SeCiCallbacks (или CiCallbacks, как я обозначал ранее) со смещением 0x20 (CiValidateImageHeader), если да - производим проверку, в противном случае возвращаем NTSTATUS равный 0xC0000428 (STATUS_INVALID_IMAGE_HASH). Call stack для SeValidateImageHeader выглядит так:Т.е, путь до проверки заголовка образа проходит от загрузки (MmLoadSystemImage) до самой валидации (SeValidateImageHeader и CiValidateImageHeader).Это справедливо и для других функций, например для SeValidateImageData и CiValidateImageData!WinDBG и DSEЗабавно, но стоит отметить, что WinDBG, если мы занимаемся отладкой ядра/бутменеджера/бутлоадера, сам отключает DSE, судя по всему это связано со структурой _LOADER_PARAMETER_CI_EXTENSIONS:Структура _LOADER_PARAMETER_CI_EXTENSIONSК сожалению, у меня она почему-то решила не загружаться (110% я криворукий долбоеб), поэтому вам придется поверить мне на слово, но обычно параметр CodeIntegrityOptions равен 6, однако, при подключенном WinDBG это поле скорее всего становится 0. Скорее всего это связано с тем, что настройки при отладке ядра изменяют это поле, а заодно вместе с ними и WinDBG. Если мы вспомним с чего мы начинали, то можем увидеть это же значение:CiOptions = 6;И, да, скорее всего это один из способов обхода механизма DSE.ВыводыВ данной статье я немного разобрал механизм инициализации Driver Signature Enforcement, а также немного рассказал, как он работает. Конечно, здесь непаханное поле экспериментов и можно еще что-то глянуть даже.Как-то так, не скучайте, не болейте, кушайте хорошо. Водички побольше пейте, воооооот.",
            "content_html": "<p><img src=\"https://telegra.ph/file/4e9862e1da916ff8cbcbe.png\" alt=\"\" /></p><p>Хм.Допустим, мы должны убедиться, что у какого-либо драйвера есть собственная цифровая подпись. Так и еще чтоб она была валидной! Логично, что для этого нужен какой-либо механизм, совершающий подобные проверки. Ну, что же, да, таков есть в Windows и ни для кого это не секрет.</p><p>Садитесь удобнее, сегодня мы попытаемся понять, где обитает DSE и почему он причиняет боль многим любителям говна в режиме ядра.</p><h2 id=\"что-такое-dse\">Что такое DSE?</h2><p>DSE - аббревиатура от словосочетания Driver Signature Enforcement. На самом деле это весьма комплексный механизм Code Integrity, он существует для “защиты” от неподписанных компонентов ядра, следовательно предполагает, что каждый драйвер устройства (или иной другой системный файл, выгружаемый в адресное пространство ядра) должен иметь собственную цифровую подпись. В противном случае, система просто откажется грузить этот компонент.Стоит на всякий случай сказать, что изменение системных файлов убивает подпись, поэтому, мои маленькие любители подрочить в ядре, это не прокатит и система скажет, что такой файл не загрузит! Так что да, эта технология существует по большому счету для защиты от вредоносов, работающих на уровне ядра. И, в принципе, он справляется вполне себе неплохо!</p><p>DSE включен по стандарту, но пользователям (только из под админа, конечно же) предоставляется возможность выключить на время проверку подписей (или включить Test Signing Mode, позволяющий загружать самоподписанные драйвера), например, через bcdedit. Правда, это чаще всего нужно только для разработчиков драйверов, когда они тестируют свои наработки.</p><p>С понятием DSE мы вроде разобрались, перейдем к теперь к его инициализации.</p><h2 id=\"инициализация-driver-signature-enforcement-и-code-integrity\">Инициализация Driver Signature Enforcement и Code Integrity</h2><p>DSE является компонентом ядра, а значит, надо искать примерно на этом уровне или чуточку ниже.</p><p>DSE берет свое начало с фазы “ранней загрузки” системы - когда свое дело закончили загрузчики (в данном случае - winload.exe/winload.efi). Это дело выгружается с основными драйверами системы. Нужный нам покемон находится в CI.dll (CodeIntegrity). Если обратить внимание на то, что экспортирует данная DLL мы однозначно можем сказать, что нам нужна функция под именем <code class=\"language-plaintext highlighter-rouge\">CiInitialize</code>:<img src=\"https://telegra.ph/file/7fb3cd9c955cf7729785a.png\" alt=\"\" /></p><p>Однако, давайте не спешить, мы зайдем немного с другого угла и чуточку уйдем от CI.dll.</p><p>Все же не менее важным для ОС, как ни странно, является ядро, а это значит, что упоминание CiInitialize должно быть и там.В действительности, так и есть, более того, эта функция также вызывается во время инициализации системы. <em>Барабанная дробь</em>…</p><p>Давайте посмотрим на функцию из ntoskrnl.exe - <code class=\"language-plaintext highlighter-rouge\">SepInitializeCodeIntegrity</code>.<img src=\"https://telegra.ph/file/6903d2a8ee5d3114b8c9e.png\" alt=\"\" /></p><p>А теперь приведем её в более приличный (и правильный) вид. Заодно я оставлю её как “код”, надеюсь, так будет удобнее:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>NTSTATUS SepInitializeCodeIntegrity() {   unsigned int CiOptions;   _LIST_ENTRY *p_BootDriverListHead;   _LOADER_PARAMETER_EXTENSION *Ext;   _LOADER_PARAMETER_CI_EXTENSION *CodeIntegrityData;   char *LoadOptions;   CiOptions = 6;   memset(&amp;CodeIntegrityCallbacks, 0, 0xC4); // nt!SeCiCallbacks   p_BootDriverListHead = 0;   SeCiCallbacks = 0xD0;   qword_140C1DAA8 = 0xA000008; // nt!SeCiCallbacks + 0xC8   if(KeLoaderBlock ) {      Ext = KeLoaderBlock-&gt;Extension;       if(Ext) {           CodeIntegrityData = Ext-&gt;CodeIntegrityData;           if(CodeIntegrityData)               CiOptions = CodeIntegrityData-&gt;CodeIntegrityOptions;       }       // (KeLoaderBlock + 0xD8)       LoadOptions = KeLoaderBlock-&gt;LoadOptions;       if(SepIsOptionPresent(LoadOptions) &amp;&amp; LoadOptions)           SeCiDebugOptions |= 1;       if(KeLoaderBlock)           p_BootDriverListHead = &amp;KeLoaderBlock-&gt;BootDriverListHead;   }   return CiInitialize(CiOptions, p_BootDriverListHead, &amp;SeCiCallbacks, SeCiPrivateApis);}</code></pre></div></div><p>Именно в этой функции мы получаем информацию о существовании <code class=\"language-plaintext highlighter-rouge\">CiInitialize</code> впервые, правда, уже через само ядро. Думаю, стоит разобрать поближе несколько моментов.</p><p>И начну я пожалуй с <code class=\"language-plaintext highlighter-rouge\">SeCiPrivateApis</code>, так как они требуют меньше объяснений и о них можно сказать прямо сейчас. Из названия логично предположить, что <code class=\"language-plaintext highlighter-rouge\">SeCiPrivateApis</code> содержит в себе список некоторых функций, с которыми работает модуль Code Integrity. Данный список содержит в себе оффсеты на функции: <code class=\"language-plaintext highlighter-rouge\">PsQueryProcessSignatureMitigationPolicy</code>, <code class=\"language-plaintext highlighter-rouge\">VslHvciInterface</code> (это оффсет на <code class=\"language-plaintext highlighter-rouge\">VslCreateSecureAllocation</code>), <code class=\"language-plaintext highlighter-rouge\">SepZwLockRegistryKey</code>, <code class=\"language-plaintext highlighter-rouge\">PsQuerySectionSignatureInformation</code>, <code class=\"language-plaintext highlighter-rouge\">SepSetRuntimeUpdatableSigningLevel</code>, <code class=\"language-plaintext highlighter-rouge\">RtlValidProcessProtection</code>, <code class=\"language-plaintext highlighter-rouge\">MmGetImageFileSignatureInformation</code> и <code class=\"language-plaintext highlighter-rouge\">SepGetSystemSigningLevel</code>.Данные функции не будут разбираться в этой статье, однако, я покажу несколько из них.<img src=\"https://telegra.ph/file/3c57bbca915d7293f7d72.png\" alt=\"\" /><img src=\"https://telegra.ph/file/b45274c032ea9926fd1b6.png\" alt=\"\" /></p><p>Назначение <code class=\"language-plaintext highlighter-rouge\">SeCiCallbacks</code> я разберу в следующем параграфе. Также, не выкидывайте из головы структуру <code class=\"language-plaintext highlighter-rouge\">_LOADER_PARAMETER_CI_EXTENSIONS</code>, с ней есть одна забавная особенность.</p><p>Кстати, забыл показать call stack. Да, функция и в правду вызывается во время инициализации:<img src=\"https://telegra.ph/file/e4abbe662744d8cde2132.png\" alt=\"\" /></p><h2 id=\"от-ядра-к-модулю\">От ядра к модулю</h2><p>Хорошо, мы поняли, что за инициализацию DSE в ядре отвечает функция <code class=\"language-plaintext highlighter-rouge\">SepInitializeCodeIntegrity</code>, данная функция срабатывает во время инициализации самой системы и она вызывает нужный нам <code class=\"language-plaintext highlighter-rouge\">CiInitialize</code>. Самое время глянуть на <code class=\"language-plaintext highlighter-rouge\">CiInitialize</code>! Ииииииии…<img src=\"https://telegra.ph/file/9c1b4d27a34a71d1aee9b.png\" alt=\"\" /></p><p>Да, это очередной враппер над еще одной функцией - <code class=\"language-plaintext highlighter-rouge\">CipInitialize</code>. Интересно, что тут мы имеем упоминание Microsoft WIL (Windows Implementation Library). Это нас не должно особо волновать, данные вещи нам не нужны и не мешают, но, решил просто это отметить.</p><p>Хорошо, <code class=\"language-plaintext highlighter-rouge\">CiInitialize</code> - это враппер. Значит, идем прямиком в <code class=\"language-plaintext highlighter-rouge\">CipInitialize</code>! И, да, это она, именно она отвечает за инициализацию нашего DSE. Это весьма большая функция, поэтому придется разместить её на нескольких скринах. Надеюсь, вы не против.<img src=\"https://telegra.ph/file/a2e2be4196b714a7a4dc8.png\" alt=\"\" /><img src=\"https://telegra.ph/file/fa5d863955762c1677c12.png\" alt=\"\" /><img src=\"https://telegra.ph/file/39ee3395136919466487d.png\" alt=\"\" /></p><p>Отлично, мы нашли, где инициализируется DSE! Давайте разберем наиболее примечательные детали.<img src=\"https://telegra.ph/file/f8d2a79350cd44cb79e01.png\" alt=\"\" /></p><p>Данный отрывок проверяет, существует ли оффсет на <code class=\"language-plaintext highlighter-rouge\">VslHvciInterface</code>. Если да - заполняет таблицу <code class=\"language-plaintext highlighter-rouge\">g_CiVslHvciInterface</code>. Я так и не смог понять, точно ли это то, что должно быть в данной таблице (да-да, называйте меня дауном-долбоебом-уебком-etc), поэтому, не упомяну ничего здесь во избежание ошибок. Но, предполагаю, что загружает оно какую-то часть функций отсюда:<img src=\"https://telegra.ph/file/0fe78ac2a60ef3ccfb6f2.png\" alt=\"\" /></p><p>Скорее всего оно загружает все, начиная с <code class=\"language-plaintext highlighter-rouge\">VslCreateSecureAllocation</code> (присутствует в <code class=\"language-plaintext highlighter-rouge\">CiPrivateApis</code>) + <code class=\"language-plaintext highlighter-rouge\">0x10</code>.</p><p>Здесь при вызове HashpSelfTest CI.dll тестирует собственную подпись, что очевидно. В условии тестируются собственные “Root Table”.<img src=\"https://telegra.ph/file/1aa55a84e5f35e98ded44.png\" alt=\"\" /><img src=\"https://telegra.ph/file/20d7bb247df59109a70da.png\" alt=\"\" /></p><p>А вот здесь у нас есть немножечко примеси Xbox (<code class=\"language-plaintext highlighter-rouge\">XciInitialize</code> импортируется из <code class=\"language-plaintext highlighter-rouge\">ext-ms-win-ci-xbox-l1-1-0</code>), живите с этим.<img src=\"https://telegra.ph/file/d193ed2b36bc07faed7c1.png\" alt=\"\" /></p><p>А вот и самое главное - таблица коллбеков! Именно функции этой таблицы и отвечают за проверку подписей, а значит, мы технически нашли, то, что нам нужно!<img src=\"https://telegra.ph/file/820e3130699acad4b27c4.png\" alt=\"\" /></p><p>Самое главное, что делает <code class=\"language-plaintext highlighter-rouge\">CipInitialize</code> - заполняет таблицу <code class=\"language-plaintext highlighter-rouge\">CiCallbacks</code>, а <code class=\"language-plaintext highlighter-rouge\">CiInitialize</code> передает заполненную таблицу ядру. Теперь, мы поняли, как иницализируется механизм проверки подписей. Осталось понять, каким образом проверяются загружаемые системные модули.</p><h2 id=\"мы-любим-только-проверенные-образы\">Мы любим только проверенные образы</h2><p>Когда необходимая таблица с указателями на функции заполнилась - система может начинать совершать проверку загружаемых образов в пространство ядра.</p><p>Опытным путем было найдено несколько функций, отвечающих за это. Например, <code class=\"language-plaintext highlighter-rouge\">SeValidateImageHeader</code>:<img src=\"https://telegra.ph/file/9799da23dd5d410bd4d46.png\" alt=\"\" /></p><p>Здесь проводится проверка, существует ли <code class=\"language-plaintext highlighter-rouge\">SeCiCallbacks</code> (или <code class=\"language-plaintext highlighter-rouge\">CiCallbacks</code>, как я обозначал ранее) со смещением <code class=\"language-plaintext highlighter-rouge\">0x20</code> (<code class=\"language-plaintext highlighter-rouge\">CiValidateImageHeader</code>), если да - производим проверку, в противном случае возвращаем NTSTATUS равный <code class=\"language-plaintext highlighter-rouge\">0xC0000428</code> (<code class=\"language-plaintext highlighter-rouge\">STATUS_INVALID_IMAGE_HASH</code>). Call stack для <code class=\"language-plaintext highlighter-rouge\">SeValidateImageHeader</code> выглядит так:<img src=\"https://telegra.ph/file/15d4b12d4eebb007309b3.png\" alt=\"\" /></p><p>Т.е, путь до проверки заголовка образа проходит от загрузки (<code class=\"language-plaintext highlighter-rouge\">MmLoadSystemImage</code>) до самой валидации (<code class=\"language-plaintext highlighter-rouge\">SeValidateImageHeader</code> и <code class=\"language-plaintext highlighter-rouge\">CiValidateImageHeader</code>).</p><p>Это справедливо и для других функций, например для <code class=\"language-plaintext highlighter-rouge\">SeValidateImageData</code> и <code class=\"language-plaintext highlighter-rouge\">CiValidateImageData</code>!</p><h2 id=\"windbg-и-dse\">WinDBG и DSE</h2><p>Забавно, но стоит отметить, что WinDBG, если мы занимаемся отладкой ядра/бутменеджера/бутлоадера, сам отключает DSE, судя по всему это связано со структурой <code class=\"language-plaintext highlighter-rouge\">_LOADER_PARAMETER_CI_EXTENSIONS</code>:<img src=\"https://telegra.ph/file/16d6ffa7b4779e041b155.png\" alt=\"\" /></p><h2 id=\"структура-_loader_parameter_ci_extensions\">Структура _LOADER_PARAMETER_CI_EXTENSIONS</h2><p>К сожалению, у меня она почему-то решила не загружаться (110% я криворукий долбоеб), поэтому вам придется поверить мне на слово, но обычно параметр CodeIntegrityOptions равен 6, однако, при подключенном WinDBG это поле скорее всего становится 0. Скорее всего это связано с тем, что настройки при отладке ядра изменяют это поле, а заодно вместе с ними и WinDBG. Если мы вспомним с чего мы начинали, то можем увидеть это же значение:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>CiOptions = 6;</code></pre></div></div><p>И, да, скорее всего это один из способов обхода механизма DSE.</p><h2 id=\"выводы\">Выводы</h2><p>В данной статье я немного разобрал механизм инициализации Driver Signature Enforcement, а также немного рассказал, как он работает. Конечно, здесь непаханное поле экспериментов и можно еще что-то глянуть даже.</p><p>Как-то так, не скучайте, не болейте, кушайте хорошо. Водички побольше пейте, воооооот.</p>",
            "url": "http://localhost:4000/2022/11/18/driver-signature-enforcement-%D0%B8%D0%BB%D0%B8-%D0%B8%D1%81%D1%81%D0%BB%D0%B5%D0%B4%D1%83%D0%B5%D0%BC-dse",
            
            
            
            "tags": ["Windows","DSE"],
            
            "date_published": "2022-11-18T00:00:00+02:00",
            "date_modified": "2022-11-18T00:00:00+02:00",
            
                "author":  {
                "name": "alchemist",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://localhost:4000/2021/12/02/kaspersky-kse",
            "title": "Как мы на Kaspersky в KSE охотились",
            "summary": "Рассматриваем как Kaspersky укрепились в KSE",
            "content_text": "Где-то примерно неделю назад один мой коллега приметил одну замечательную вещь: Kaspersky интересным образом протянул свои ручки к Kernel Shim Engine.В итоге мы собрались где-то вчера разгребать и смотреть, что он там забыл. Также попытались распилить и отловить шим Касперского, но об этом чуть позже.ВводныеНачнем с понимания, что это вообще за зверь такой - Kernel Shim Engine.Технически Kernel Shim Engine (далее KSE) предоставляет “обертки” для драйверов устройств, а также обеспечивает дополнительную поддержку и обработку ошибок драйверов устройств. У него есть своя специальная база данных, мы затронем её позже.Также стоит поговорить о кое чем еще.Инициализация шимовЕсли говорить в кратце и не вдаваться в подробности работы, то шимы инициализируются на этапе загрузки системы, где-то сразу после того, как инциализировался HAL (Hardware Abstraction Layer) и WMI (Windows Management Instrumentation) с ETW (Event Tracing for Windows). После прогрузки HAL, WMI и ETW вызывается функция KseInitialize(), а после нее KseRegisterShim(). Эти функции официально не документированы, но находятся в некоторых заголовочных файлах WDK.Инициализация “Built-in” шимов драйверовВ конце инициализации HAL происходит инициализация шима DriverScope, этот шим преоставляется по стандарту системой:Затем, во время инициализации WMI/ETW также инициализируется функция KseVersionLieInitialize(). Данная функция инициализирует шимы KmWin7VersionLie, KmWin8VersionLie и KmWin81VersionLie (хоть тесты и производились на десятке, но подобный шим с версией “10” я не обнаружил):Потом вызывается функция KseSkipDriverUnloadInitialize(), которая инициализирует шим SkipDriverUnload.Функции Касперского в ядреОкей, вроде +- разобрались. Теперь, какие функции были найдены мной, затрагивающие шимы:Доступ был только к функции к KseKasperskyInitialize():Сперва мы решили посмотреть, как поведет себя Касперский при манипуляции с реестром, а конкретнее:  HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Policies\\Microsoft\\Compatibility    С ключами DisableDeviceFlags и DisableDriverShims (REG_DWORD), их значения равны единицы, очевидно по названиям ключей, что они делают при значении 0x01.  HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Compatibility    С ключем DisableFlags (REG_DWORD) со значением 0x01 (отключает функциональность драйвера).В нашем случае Касперский никак себя не повел, тем более он спокойно дал изменить значения регистров, т.е эти ключи реестра не мониторятся Касперским.Как поломать KSEМожно сломать KSE двумя путями: мониторинг драйвера через Verifier и с помощью удаления drvmain.sdb.Мы вполне имеем право поставить Verifier на драйвер Касперского, ну или удалить сам drvmain.sdb, но скорее всего это вызовет BSOD.drvmain.sdbМы все же решили для начала порыться в drvmain.sdb. Стоит сказать, что до мониторинга и удаления мы не дошли, а почему - вы поймете позже.drvmain.sdb - стандартная база данных “легальных” драйверов и не только. Помимо драйверов, там также находится информация о шимах и других вещах.Этот файл находится в “%systemroot%/apppatch/”. Файлы с расширением sdb можно открыть, к примеру, через SDBExplorer.Видим в drvmain вот такую картину:Да, список драйверов Касперского, ничего удивительного. Можно было бы ставить Verifier на klhk.sys и идти отлавливать шим Касперского, но не все так просто.KSHIM и почему все печально закончилосьВ drvmain, как и упоминалось выше, есть не только перечисление драйверов, а также некоторые шимы.Представляются они в виде структуры KSHIM, которая по сути является структурой KSE_SHIM, только слегка измененной:typedef struct _KSE_SHIM {  _In_ ULONG Size;  _In_ PGUID ShimGuid;  _In_ PWCHAR ShimName;  _Out_ PVOID KseCallbackRoutines;  _Inopt_ PVOID ShimmedDriverTargetedNotification;  _Inopt_ PVOID ShimmedDriverUntargetedNotification;  _In_ PVOID HookCollectionsArray;} KSE_SHIM, *PKSE_SHIM;Вот как выглядит KSHIM Касперского:Заметьте, что поле MODULE несет значение “NT kernel component”. А теперь можем посмотреть на ndis шимы:Да, тут поле MODULE со значением “ndis”. Думаю, можно догадаться, в чем проблема.Ага, это значит, что шим Касперского существует в пространстве самого ядра системы. А это значит, что кроме как накидывая Verifier на ядро мы отследить шим Касперского не сможем. Вот, только если накидывать его на ядро, сломается не только Касперский, но и сама система. Прикольно, правда?Возможный путь отлова шима КасперскогоВ мою голову лезет только анализ дампа системы. Т.е мы должны завершить систему аварийно, при этом сгенерировав дамп системы, где был запущен Касперский. Команда “.crash” (если не ошибаюсь) из windbg вполне решит эту проблему. Я, правда, не уверен, что мы сможем вытащить что-то дельное, но попытка не пытка, как говорится.Послесловие и догадкиТеоретически, _KSE_SHIM - пользовательский ввод. Есть смысл посидеть над драйвером ndis.sys (сама структура оттуда). Однако, стучать туда через непривелегированного пользователя мы не сможем, но вполне вероятно, что до туда сможет достать TrustedInstaller.",
            "content_html": "<p>Где-то примерно неделю назад один мой коллега приметил одну замечательную вещь: Kaspersky интересным образом протянул свои ручки к Kernel Shim Engine.</p><p>В итоге мы собрались где-то вчера разгребать и смотреть, что он там забыл. Также попытались распилить и отловить шим Касперского, но об этом чуть позже.</p><h2 id=\"вводные\">Вводные</h2><p>Начнем с понимания, что это вообще за зверь такой - Kernel Shim Engine.Технически Kernel Shim Engine (далее KSE) предоставляет “обертки” для драйверов устройств, а также обеспечивает дополнительную поддержку и обработку ошибок драйверов устройств. У него есть своя специальная база данных, мы затронем её позже.</p><p>Также стоит поговорить о кое чем еще.</p><h2 id=\"инициализация-шимов\">Инициализация шимов</h2><p>Если говорить в кратце и не вдаваться в подробности работы, то шимы инициализируются на этапе загрузки системы, где-то сразу после того, как инциализировался HAL (Hardware Abstraction Layer) и WMI (Windows Management Instrumentation) с ETW (Event Tracing for Windows). После прогрузки HAL, WMI и ETW вызывается функция <code class=\"language-plaintext highlighter-rouge\">KseInitialize()</code>, а после нее <code class=\"language-plaintext highlighter-rouge\">KseRegisterShim()</code>. Эти функции официально не документированы, но находятся в некоторых заголовочных файлах WDK.</p><h2 id=\"инициализация-built-in-шимов-драйверов\">Инициализация “Built-in” шимов драйверов</h2><p>В конце инициализации HAL происходит инициализация шима <code class=\"language-plaintext highlighter-rouge\">DriverScope</code>, этот шим преоставляется по стандарту системой:<img src=\"https://telegra.ph/file/6a7e823e4f6994c25239a.png\" alt=\"\" /></p><p>Затем, во время инициализации WMI/ETW также инициализируется функция <code class=\"language-plaintext highlighter-rouge\">KseVersionLieInitialize()</code>. Данная функция инициализирует шимы <code class=\"language-plaintext highlighter-rouge\">KmWin7VersionLie</code>, <code class=\"language-plaintext highlighter-rouge\">KmWin8VersionLie</code> и <code class=\"language-plaintext highlighter-rouge\">KmWin81VersionLie</code> (хоть тесты и производились на десятке, но подобный шим с версией “10” я не обнаружил):<img src=\"https://telegra.ph/file/6696892d9103caf951ff6.png\" alt=\"\" /></p><p>Потом вызывается функция <code class=\"language-plaintext highlighter-rouge\">KseSkipDriverUnloadInitialize()</code>, которая инициализирует шим <code class=\"language-plaintext highlighter-rouge\">SkipDriverUnload</code>.</p><h2 id=\"функции-касперского-в-ядре\">Функции Касперского в ядре</h2><p>Окей, вроде +- разобрались. Теперь, какие функции были найдены мной, затрагивающие шимы:</p><p><img src=\"https://telegra.ph/file/7503d5cdb5fbbe607e2ea.png\" alt=\"\" /></p><p>Доступ был только к функции к <code class=\"language-plaintext highlighter-rouge\">KseKasperskyInitialize()</code>:<img src=\"https://telegra.ph/file/454425e15d9dc8fbc91b7.png\" alt=\"\" /></p><p>Сперва мы решили посмотреть, как поведет себя Касперский при манипуляции с реестром, а конкретнее:</p><ul>  <li><code class=\"language-plaintext highlighter-rouge\">HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Policies\\Microsoft\\Compatibility</code>    С ключами DisableDeviceFlags и DisableDriverShims (REG_DWORD), их значения равны единицы, очевидно по названиям ключей, что они делают при значении 0x01.</li>  <li><code class=\"language-plaintext highlighter-rouge\">HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Compatibility</code>    С ключем DisableFlags (REG_DWORD) со значением 0x01 (отключает функциональность драйвера).</li></ul><p><img src=\"https://telegra.ph/file/d28d92c33c10e020b0a13.png\" alt=\"\" /></p><p><img src=\"https://telegra.ph/file/7882dbc6a7958bb351b22.png\" alt=\"\" /></p><p>В нашем случае Касперский никак себя не повел, тем более он спокойно дал изменить значения регистров, т.е эти ключи реестра не мониторятся Касперским.</p><h2 id=\"как-поломать-kse\">Как поломать KSE</h2><p>Можно сломать KSE двумя путями: мониторинг драйвера через Verifier и с помощью удаления drvmain.sdb.Мы вполне имеем право поставить Verifier на драйвер Касперского, ну или удалить сам drvmain.sdb, но скорее всего это вызовет BSOD.</p><h2 id=\"drvmainsdb\">drvmain.sdb</h2><p>Мы все же решили для начала порыться в drvmain.sdb. Стоит сказать, что до мониторинга и удаления мы не дошли, а почему - вы поймете позже.</p><p>drvmain.sdb - стандартная база данных “легальных” драйверов и не только. Помимо драйверов, там также находится информация о шимах и других вещах.Этот файл находится в “%systemroot%/apppatch/”. Файлы с расширением sdb можно открыть, к примеру, через SDBExplorer.</p><p>Видим в drvmain вот такую картину:<img src=\"https://telegra.ph/file/43166105e211864bb3a9d.png\" alt=\"\" /></p><p>Да, список драйверов Касперского, ничего удивительного. Можно было бы ставить Verifier на klhk.sys и идти отлавливать шим Касперского, но не все так просто.</p><h2 id=\"kshim-и-почему-все-печально-закончилось\">KSHIM и почему все печально закончилось</h2><p>В drvmain, как и упоминалось выше, есть не только перечисление драйверов, а также некоторые шимы.Представляются они в виде структуры KSHIM, которая по сути является структурой KSE_SHIM, только слегка измененной:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>typedef struct _KSE_SHIM {  _In_ ULONG Size;  _In_ PGUID ShimGuid;  _In_ PWCHAR ShimName;  _Out_ PVOID KseCallbackRoutines;  _Inopt_ PVOID ShimmedDriverTargetedNotification;  _Inopt_ PVOID ShimmedDriverUntargetedNotification;  _In_ PVOID HookCollectionsArray;} KSE_SHIM, *PKSE_SHIM;</code></pre></div></div><p>Вот как выглядит KSHIM Касперского:<img src=\"https://telegra.ph/file/6de97f18ed595c54a1a32.png\" alt=\"\" /></p><p>Заметьте, что поле MODULE несет значение “NT kernel component”. А теперь можем посмотреть на ndis шимы:<img src=\"https://telegra.ph/file/d9be19f43a929c8b93057.png\" alt=\"\" /></p><p>Да, тут поле MODULE со значением “ndis”. Думаю, можно догадаться, в чем проблема.</p><p>Ага, это значит, что шим Касперского существует в пространстве самого ядра системы. А это значит, что кроме как накидывая Verifier на ядро мы отследить шим Касперского не сможем. Вот, только если накидывать его на ядро, сломается не только Касперский, но и сама система. Прикольно, правда?</p><h2 id=\"возможный-путь-отлова-шима-касперского\">Возможный путь отлова шима Касперского</h2><p>В мою голову лезет только анализ дампа системы. Т.е мы должны завершить систему аварийно, при этом сгенерировав дамп системы, где был запущен Касперский. Команда “.crash” (если не ошибаюсь) из windbg вполне решит эту проблему. Я, правда, не уверен, что мы сможем вытащить что-то дельное, но попытка не пытка, как говорится.</p><h2 id=\"послесловие-и-догадки\">Послесловие и догадки</h2><p>Теоретически, <code class=\"language-plaintext highlighter-rouge\">_KSE_SHIM</code> - пользовательский ввод. Есть смысл посидеть над драйвером ndis.sys (сама структура оттуда). Однако, стучать туда через непривелегированного пользователя мы не сможем, но вполне вероятно, что до туда сможет достать TrustedInstaller.</p>",
            "url": "http://localhost:4000/2021/12/02/kaspersky-kse",
            
            
            
            "tags": ["Windows","AV","KSE"],
            
            "date_published": "2021-12-02T00:00:00+02:00",
            "date_modified": "2021-12-02T00:00:00+02:00",
            
                "author":  {
                "name": "alchemist",
                "url": null,
                "avatar": null
                }
                
            
        }
    
    ]
}